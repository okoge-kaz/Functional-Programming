# 関数型プログラミング

## 第１回

[Link](https://htdp.org/2018-01-06/Book/part_prologue.html)

## 第2回

- プログラム: レシピ, プロセス: 料理人

  同一のプログラムから別々の独立なプロセスを持つことができる。
  (もちろんデータを共有することもできるが、普通は独立)

- アセンブリ言語：　機械語`0110 000 001 000 011`を`ADD R1 R3`のようなニモニックによる可読性の向上

  また、アセンブラではジャンプ命令などの飛ぶ先のアドレスを自動計算してくれたりするので、機械語より圧倒的に楽

  ただし、アセンブリ言語はマシンに依存している。それから離れたのが、高級言語 C, FORTRANとか

- LISP：関数型言語　Schemeの仲間
  記号処理ができることが偉大だった。微分処理とかができるので、FORTRANのように数値計算しかできない言語とは大きく異なる。
  ラムダ計算が計算の基本になっている。

- 1.6
  ```c
  int square(int n){
    return n*n;
  }
  int main(){
    int n; scanf("%d", n);
    printf("%d", square(n));
  }
  ```

  抽象化: `square`のこと

- 1.8

  Schemeのインタープリタを起動すると、大域環境という基本的な演算が定義された環境が起動する。   
  そこで、`define`を用いると、`define`で定義した変数がその大域環境に追加される。

- 1.9 
  
  `式の各要素の評価` で`PI`など`define`されたデータを大域環境から参照する。  
  `*`を見たら`掛け算`であると解釈され、２つの引数についてみるといった具合

  `define`が特殊ケースである理由は、もし`define`という手続きが通常の処理なら、`PI`を定義するために`PI`という変数？の数値をとってこないといけない。（そうでないと評価できない。）これでは、卵が先か鶏が先か問題になってしまう。よって`define`は特殊ケース。このように、`define`は第２引数は評価するが、第１引数は評価しない。

- Q1.1

  `(+ 2 3)` : 式の各要素を評価し、`+`という`手続き`にしたがって、第１引数の`2`を、第２引数の`3`に適応する。評価結果は、`5`となる。中置形式であらわすと`2 + 3`となる。

  `(* (+ 2 3) 4 )` : 式の各要素を評価し、`*`という`手続き`にしたがって、第１引数の`(+ 2 3)`を、第２引数の`3`に適応する。このとき、第１引数の`(+ 2 3)`は、上記のように評価され、その結果が用いられる。評価結果は、`20`となる。中置形式であらわすと`(2 + 3) * 4`となる。

- Q1.2

  `define`が特殊形式でないとすると、`define`の第１引数の`名前`を評価しなくてはならなくなり、問題が生じるため

- 1.12  
  $\lambda$抽象
  `(lambda (x) (* x x))` 手続きの抽象化(引数を２乗するもの)

  `(lambda (x y) (* x y))`とかも書ける   
  `lambda`式も手続ではなく、特殊形式である。

- 1.15

  糖衣構文(syntax sugar)   
  ```scheme
  (define <name> (lambda (<argument>) <proceduere> ))
  ```
  というものを簡略化できる。


- 1.16

  (2)の`仮引数を実引数で置き換えて手続きの本体を評価`ということに注意  
  すなわち、かならず基本手続きまで分解されて、そこまで分解されてから実行される。すなわち、評価の再帰関数は基本手続きまで到達したら止まる。

- 1.17

  `if`も特殊形式 これは明らかで、なぜなら、通常の規則なら$p, e_t, e_f$すべてに`if`という規則を適応するから

- Q1.3

  `(+ 2 (square 5))`は、`+`を評価し基本手続きの足し算だと解釈し、次に`2`はただの数値と解釈し、続けて第２引数の`(square 5)`を評価する。このとき帯域環境に存在する`square`を参照し、仮引数である`x`を`5`に置き換えて`(* 5 5)`となったものを評価する。この結果は`25`であるので、基本手続きに従って`27`となる。

- Q1.4

  ```scheme
  (or ( and ( x > 0 ) ( y < 100 ) ) ( not (z = 0) ) )
  ```


## 第4回

```scheme
(define (fact n)
  (if (= n 0) 1 (* n (fact (- n 1))))
)
```
schemeでの再帰関数は上記のように書く。これは、cppの以下のコードと同様である。
```cpp
int fact(int n){
  if(n == 0) return 1;
  else{
    return n * fact(n-1);
  }
}
```

```scheme
(define (fact2 n) (facti n 1))

(define (facti n a
  (if (= n 0) a (facti (- n 1) (* n a))))
)
```

- Q2.1
基底: `(if (= n 0) 1 ..`のところ
再帰: ``

末尾再帰かどうかの判定は、最終的に返す値を計算する手続きは`facti`になっている。一方で、普通の再帰では`(* n (fact (- n 1)))`のように、最後に使われる手続きは`*`であるということ

末尾再帰の場合は、最後に用いられる最後の規則は`fibi`
普通の再帰は、最後に使う手続きは`+`だったり`*`だったりする